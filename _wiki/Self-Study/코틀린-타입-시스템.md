### 널 아님 단언(not-null assertion): !!
**널 아님 단언** 은 코틀린에서 널이 될 수 있는 타입의 값을 다룰 때 사용할 수 있는 도구 중에서 가장 단순하면서도 무딘 도구다. 느낌표를 이중(!!)으로 사용하면 어떤 값이든 널이 될 수 없는 타입으로 강제로 바꿀 수 있다. 실제 널에 대해 !!를 적용하면 NPE가 발생한다.
다음은 널 아님 단언을 사용해 널이 될 수 있는 인자를 널이 될 수 없는 타입으로 변환하는 간단한 예제다.

```kotlin
fun ignoreNulls(s: String?){
    val sNotNull: String = s!!
    println(sNotNull.length)
}
// ignoreNulls(null)
// Exception in thread "main" kotlin.KotlinNullPointerException
```

s가 null이면 함수 안에서 어떤 일이 벌어질까? 예외를 던지는 일 외에 코틀린이 택할 수 있는 대안이 별로 없다. 하지만 발생한 예외는 null값을 사용하는 코드(sNotNull.length가 있는 줄)가 아니라 단언문이 위치한 곳을 가리킨다. 근본적으로 !!는 컴파일러에게 **"나는 이 값이 null이 아님을 잘 알고 있다. 내가 잘못 생각했다면 예외가 발생해도 감수하겠다"** 라고 말하는 것이다. 

> 아마도 !!가 약간 무례해 보일 것이다. !! 기호는 마치 컴파일러에게 소리를 지르는 것 같은 느낌을 줄 수 있음. 사실 이는 의도된 것. 코틀린 설계자들은 컴파일러가 검증할 수 없는 단언을 사용하기보다는 더 나은 방법을 찾아보라는 의도를 넌지시 표현하려고 !!라는 기호를 택했다.

하지만 널 아님 단언문이 더 나은 해법인 경우도 있다. 어떤 함수가 값이 널인지 검사한 다음에, 다른 함수를 호출한다고 해도, 컴파일러는 호출된 함수 안에서 안전하게 그 값을 사용하고 있음을 인식할 수 없다. 하지만 이런 경우 호출된 함수가 언제나 다른 함수에서 널이 아닌 값을 전달받는다는 사실이 분명하다면 굳이 널 검사를 다시 수행하고 싶지 않을 것이다. 이럴 때는 널 아님 단언문을 쓸 수 있다.
실무에서는 스윙과 같은 다양한 UI 프레임워크에 있는 액션 클래스에서 이런 일이 자주 발생한다. 액션 클래스 안에는 그 액션 상태를 변경하는 메소드와 실제 액선을 실행하는 메소드가 있다. update 메소드 안에서 검사하는 조건을 만족하지 않는 경우 execute 메소드는 호출될 수 없다. 하지만 컴파일러는 그런 연관 관계를 알 방법이 없다. 
이런 상황에서 널 아님 단언을 사용하는 스윙 액션 예제를 살펴보자. CopyRowAction은 리스트 컨트롤에서 선택된 줄을 클립보드에 복사한다고 가정하자. 설명에 불필요한 자세한 부분은 생략하고 어떤 줄이 선택됐는지 여부를 검사(줄이 선택되면 액션을 실행할 수 있다는 뜻)하고 선택된 줄의 정보를 가져오는 부분만을 남겼다. 액션 API는 isEnabled가 true인 경우 actionPerformed를 호출해준다고 가정하자.

```kotlin
class CopyRowAction(val list: JList<String>): AbstractAction(){
    override fun isEnabled(): Boolean = 
        list.selectedValue != null
    override fun actionPerformed(e: ActionEvent) {
        val value = list.selectedValue!!
    }
}
// actionPerformed는 isEnabled가 true인 경우에만 호출된다.
```

이 경우 !!를 사용하지 않으려면 val value = list.selectedValue ?: return 처럼 널이 될 수 없는 타입의 값을 얻어야 한다. 이런 패턴을 사용하면 list.selectedValue가 null이면 함수가 **조기 종료** 되므로 함수의 나머지 본문에서는 value가 항상 null이 아니게 된다. 이 식에서 엘비스 연산자는 중복이라 할 수 있지만 나중에 isEnabled가 더 복잡해질 가능성에 대비해 미리 보호 장치를 마련해 둔다고 생각할 수 있다. 
기억해야만 하는 함정이 하나 더 있다. !!를 널에 대해 사용해서 발생하는 예외의 스택 트레이스에는 어떤 파일의 몇 번째 줄인지에 대한 정보는 들어있지만 어떤 식에서 예외가 발생했는지에 대한 정보는 들어있지 않다. 어떤 값이 널이었는지 확실히 하기 위해 여러 !!단언문을 한 줄에 함께 쓰는 일을 피해야 한다. 

```kotlin
person.company!!.address!!.country // 이런 식으로 코드를 작성하면 안 된다.
```

지금까지는 널이 될 수 있는 타입의 값에 어떻게 접근하는지에 대해 주로 살펴봤다. 

### let 함수
let 함수를 사용하면 널이 될 수 있는 식을 더 쉽게 다룰 수 있다. let 함수를 안전한 호출 연산자(?.)와 함께 사용하면 원하는 식을 평가해서 결과가 널인지 검사한 다음에 그 결과를 변수에 넣는 작업을 간단한 식을 사용해 한꺼번에 처리할 수 있다. 
let을 사용하는 가장 흔한 용례는 널이 될 수 있는 값을 널이 아닌 값만 인자로 받는 함수에 넘기는 경우다. 이메일을 보내는 sendEmailTo 함수가 이메일 주소를 String 타입의 파라미터로 받는다고 하자. 이 함수는 코틀린으로 작성됐으며 널이 아닌 파라미터를 받는다.

```kotlin
fun sendEmailTo(email: String){}
```

이 함수에게 널이 될 수 있는 타입의 값을 넘길 수는 없음. 인자를 넘기기 전에 주어진 값이 널인지 검사해야 한다.

```kotlin
if(email != null) sendEmailTo(email)
```

하지만 let 함수를 통해 인자를 전달할 수도 있다. let 함수는 자신의 수신 객체를, 인자로 전달받은 람다에게 넘긴다. 널이 될 수 있는 값에 안전한 호출 구문(?.)을 사용해 let을 호출하되 널이 될 수 없는 타입을 인자로 받는 람다를 let에 넘긴다. 이렇게 하면 널이 될 수 있는 타입의 값을 널이 될 수 없는 타입의 값으로 바꿔서 람다에 전달하게 된다. 
let 함수는 이메일 주소 값이 널이 아닌 경우에만 호출된다. 따라서 다음 예제의 람다 안에서는 널이 될 수 없는 타입으로 이메일을 사용할 수 있다. 

```kotlin
email?.let{ sendEmailTo(it) }
```

```kotlin
fun sendEmailTo(email: String){
    println("Sending email to $email")
}

email?.let { sendEmailTo(it) }
```

아주 긴 식이 있고 그 값이 널이 아닐 때 수행하는 로직이 있을 때 let을 쓰면 훨씬 더 편하다. let을 쓰면 긴 식의 결과를 저장하는 변수를 따로 만들 필요가 없다. 다음은 명시적인 if 검사가 있다고 하자.

```kotlin
val person: Person? = getTheBestPersonInTheWorld()
if(person != null) sendEmailTo(person.email)
```

굳이 person 변수를 추가할 필요 없이 다음과 같이 쓸 수 있다. 
```kotlin
getTheBestPersonInTheWorld()?.let{ sendEmailTo(it.email) }
```

다음 getTheBestPersonInTheWorld() 함수는 null을 반환한다. 따라서 위의 람다식은 결코 실행되지 않는다. 

```kotlin
fun getTheBestPersonInTheWorld(): Person? = null
```

여러 값이 널인지 검사해야 한다면 let 호출을 중첩시켜서 처리할 수 있다. 그렇게 let을 중첩시켜 처리하면 코드가 복잡해져서 알아보기 어려워진다. 그런 경우 **일반적인 if를 사용해 모든 값을 한꺼번에 검사하는 편이 낫다.**
자주 발생하는 다른 상황으로, 실제로는 널이 될 수 없는 프로퍼티인데 **생성자 안에서 널이 아닌 값으로 초기화할 방법이 없는 경우**가 있다. 이런 상황을 코틀린에서 어떻게 처리할 수 있는지 살펴보자. 

### 나중에 초기화할 프로퍼티
객체 인스턴스를 일단 생성한 다음에 나중에 초기화하는 프레임워크가 많다. 예를 들어 안드로이드에서는 onCreate에서 액티비티를 초기화한다. JUnit에서는 @Before로 애노테이션된 메소드 안에서 초기화 로직을 수행해야만 한다.
하지만 코틀린에서는 클래스 안의 널이 될 수 없는 프로퍼티를 생성자 안에서 초기화하지 않고 특별한 메소드 안에서 초기화할 수는 없다. 코틀린에서는 일반적으로 생성자에서 모든 프로퍼티를 초기화해야 한다. 게다가 프로퍼티 타입이 널이 될 수 없는 타입이라면 반드시 널이 아닌 값으로 그 프로퍼티를 초기화 해야한다. 그런 초기화 값을 제공할 수 없으면 널이 될 수 있는 타입을 사용할 수밖에 없다. 하지만 널이 될 수 있는 타입을 사용하면 모든 프로퍼티 접근에 널 검사를 넣거나 !! 연산자를 써야 한다. 

```kotlin
class MyService{
    fun performAction(): String = "foo"
}

class MyTest{
    private var myService: MyService? = null
    @Before fun setUp(){
        myService = MyService()
    }
    @Test fun testAction() {
        Assert.assertEquals("foo", myService!!.performAction())
    }
}
```

이 코드는 보기 나쁘다. 특히 프로퍼티를 여러 번 사용해야 하면 코드가 더 못생겨진다(여기서는 myService). 이를 해결하기 위해 myService 프로퍼티를 나중에 초기화(late-initialized)할 수 있다. lateinit 변경자를 붙이면 프로퍼티를 나중에 초기화 할 수 있다. 

```kotlin
class MyService{
    fun performAction(): String = "foo"
}

class MyTest{
    private lateinit var myService: MyService // 초기화하지 않고 널이 될 수 없는 프로퍼티를 선언한다.
    
    @Before fun setUp(){
        myService = MyService() // setUp()에서 프로퍼티를 초기화한다.
    }
    
    @Test fun testAction(){
        Assert.assertEquals("foo",
            myService.performAction() // 널 검사를 수행하지 않고 프로퍼티를 사용한다.
    }
}
```

나중에 초기화하는 프로퍼티는 항상 var이어야 한다. val 프로퍼티는 final 필드로 컴파일되며, 생성자 안에서 반드시 초기화되어야 한다. 따라서 생성자 밖에서 초기화해야 하는 '나중에 초기화하는 프로퍼티'는 항상 var이어야 한다. 그렇지만 나중에 초기화하는 프로퍼티는 널이 될 수 없는 타입이라 해도 더 이상 생성자 안에서 초기화할 필요가 없다. 그 프로퍼티를 초기화하기 전에 프로퍼티에 접근하면 "lateinit property myService has not benn initialized"이라는 예외가 발생한다. 예외를 보면 어디가 잘못됐는지 확실히 알 수 있다. 단순히 NPE가 발생하는 것보다 훨씬 좋음.

> lateinit 프로퍼티를 의존관계 주입(DI) 프레임워크와 함께 사용하는 경우가 많다. 그런 시나리오에서는 lateinit 프로퍼티 값을 DI 프레임워크가 외부에서 설정해준다. 다양한 자바 프레임워크와의 호환성을 위해 코틀린은 lateinit가 지정된 프로퍼티와 가시성이 똑같은 필드를 생성해준다(?) 어떤 프로퍼티가 public이면 코틀린이 생성한 필드도 public이다. 
> 이제 널이 될 수 있는 타입을 확장함으로써 널 값을 다루는 새로운 도구를 추가하는 방법에 대해 살펴보자.

### 널이 될 수 있는 타입 확장
널이 될 수 있는 타입에 대한 확장 함수를 정의하면 null 값을 다루는 강력한 도구로 활용할 수 있다. 어떤 메소드를 호출하기 전에 수신 객체 역할을 하는 변수가 널이 될 수 없다고 보장하는 대신, 직접 변수에 대해 메소드를 호출해도 확장 함수인 메소드가 알아서 널을 처리해준다. 이런 처리는 확장 함수에서만 가능하다. 일반 멤버 호출은 객체 인스턴스를 통해 디스패치 되므로 그 인스턴스가 널인지 여부를 검사하지 않는다. 
예를 들어 코틀린 라이브러리에서 String을 확장해 정의된 isEmpty와 isBlank라는 함수를 생각해보자. isEmpty는 문자열이 빈 문자열("")인지 검사하고, isBlank는 문자열이 모두 공백 문자로 이루어져 있는지 검사한다. 이 문자열로 무언가 의미있는 작업을 수행하고 싶은 경우 보통 이런 함수들로 문자열을 검사할 것이다. isEmpty나 isBlank처럼 널을 검사할 수 있다면 편하지 않을까? 실제로 String? 타입의 수신 객체에 대해 호출할 수 있는 isNullOrEmptysk isNullOrBlank 메소드가 있다. :
