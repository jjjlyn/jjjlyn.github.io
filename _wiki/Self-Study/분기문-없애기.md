### 할인정책을 분기로 처리하는 코드

public class PaymentService {
    public Discount getDiscount(...){   
        long productAmt = ...;
        String discountCode = ...;
        
        long discountAmt = 0;
        if("NAVER".equals(discountCode)){
            discountAmt = productAmt * 0.1;
        } else if ("DANAWA".equals(discountCode)){
            discountAmt = procuctAmt * 0.15;
        } else if ("FANCAFE".equals(discountCode)){
            if(productAmt < 1000)
                discountAmt = productAmt;
            else discountAmt = 1000;
        }
        return Discount.of(discountAmt, ...);
    }
    
    ... 
}

같은 유형의 분기문이 메소드 곳곳에서 발견된다.
위와 같은 코드가 보이면 일반적으로 중복 제거를 위해서 메소드 추출을 통한 리팩토링을 하게 된다. 일반적인 메소드 추출은 기존 절차적 프로그래밍에서 가능한 리팩토링 기법. 여기서 중요한 것은 getDiscountAmount 즉 할인에 관한 정책 분기를 결제 서비스 객체(Payment Service)에 두는 것이 맞느냐이다. 할인과 결제는 분리되는 것이 낫다. 

두 관계를 더 구체적으로 보면 쇼핑몰 도메인 상 할인과 결제가 연관관계를 가지고 있긴 한데, 이게 강결합이 돼서는 안되고 유연성을 가져야 한다. 또한 이 객체 뿐 아니라 다른 객체에서 할인 로직을 사용할 시에는 getDiscountAmt 메소드가 중복으로 발생하게 된다. if-else도 중복이 될 것이다. 
여기서 추상화할 영역을 추출해야 한다. 추상화를 시도할 시 책임(역할)을 기반으로 분리할 도메인 로직의 핵심을 집어내야 한다. 현재 예제에서 분리할 도메인 로직은 할인이다. 할인 로직의 핵심은 할인 금액을 구하는 것. 즉 getDiscountAmt가 분리할 핵심적인 행위(메소드)가 되며, 추상화시키면 되는 것이다. 
이제 할인할 수 있는 추상화를 기반으로 해당 인터페이스를 추출하겠다. 하나의 클래스로 각 할인 정책이 분리된다. 이런 기법을 인터페이스 추출이라고 한다. 

public interface Discountable {
    Discountable NONE = new Discountable(){
        @Override
        public long getDiscountAmt(long originAmt){
            return 0;
        }
    };
    
    long getDiscountAmt(long originAmt);
}

class NaverDiscountPolicy implements Discountable {
    @Override
    public long getDiscountAmt(long originAmt){
        return originAmt * 0.1;
    }
}

public class PaymentService {
    public Discount getDiscount(...){
        long productAmt = ...;
        String discountCode = ...;
        Discountable discountPolicy = getDiscounter(discountCode);
        
        long discountAmt = discountPolicy.getDiscountAmt(productAmt);
    }
    
    private Discountable getDiscounter(String discountCode){
        if("NAVER".equals(discountCode)){
            return new NaverDiscountPolicy();
        } else if("DANAWA".equals(discountCode)){
            return new DanawaDiscountPolicy();
        } else if("FANCAFE".equals(discountCode)){
            return new FancafeDiscountPolicy();
        } else {
            return Discountable.NONE;
        }
    }
    
    public void payment(...){
        long productAmt = ...;
        String discountCode = ...;
        Discountable discountPolicy = getDiscounter(discountCode);
        
        long paymentAmt = productAmt - discountPolicy.getDiscountAmt(productAmt);
    }
}

인터페이스를 적절하게 추출하였으나 팩토리 메소드가 해당 객체 내에 있기 때문에 아직 완벽하게 클라이언트 객체(PaymentService)와 할인 구상 클래스가 강결합 상태다. 그래서 getDiscounter(String) 팩토리 메서드, 즉 할인정책을 생성하는 메소드도 분리해야 한다. 이번에도 이전과 마찬가지로 인터페이스 추출을 시도할 것인데 여기서 분리할 것은 바로 할인 정책 생성이다. 

public interface DiscounterFactory {
    Discountable getDiscounter(String discountName);
}

public class SimpleDiscounterFactory implements DiscounterFactory {
    @Override
    Discountable getDiscounter(String discountName){
        if("NAVER".equals(discountCode)){
            return new NaverDiscountPolicy();
        }
    }
}


discounterFactory = new SimpleDiscounterFactory();

public Discount getDiscount(...){
...
}

public void payment(...){
...
}

private Discountable getDiscounter(String discountCode){
    return discounterFactory.getDiscounter(discountCode);
}

Enum을 사용하는 것도 괜찮다.

public enum DiscountPolicy implements Discountable {
    NAVER(10, 0L){
        @Override
        public long getDiscountAmt(long originAmt){
            return originAmt * this.discountRate

