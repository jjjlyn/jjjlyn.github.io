sum
int a, int b
int
a와 b를 더한 값을 결과로 돌려줌. 즉 sum(10, 15)는 25가 되어야 함

class Calculator {
    fun sum(a: Int, b: Int) : Int{
        return 0
    }
}


class CryptoListUseCaseUnitTest {
    @Rule
    @JVMField
    val rule = InstantTaskExecutorRule()

    val coinMarketCapRepository = mock<CoinMarketCapRepository>()

    val cryptoListUseCases by lazy {
        CryptoListInteractor(coinMarketCapRepository)
    }

    @Test
    fun testCryptyListUseCases_getcryptoList_Completed(){
        whenever(coinMarketCapRepository.getCryptoList(anyInt(), anyInt()))
        .thenReturn(Single.just(emptyList()))

        cryptoListUseCases.getCryptoListBy(0)
        .test()
        .assertComplete()
    }
}

만일 생성된 계좌가 null이라면 예외를 발생시키도록 ㅁ만들었다. 
여전히 Account ZMFFOTJ
public class AccountTest {
    public void testAccount(){
        Account account = new Account();
        if(account == null){
            throw new Exception("계좌 생성 실패");
        }
    }
}

여전히 Account 클래스 타입 선언부는 문제가 있다고 표시된다. 하지만 테스트 시나리오 코드로
표현하는 일은 완료됐다. 만일 testAccount() 메소드를 실행했을 때
어떤 문제나 메시지도 발생하지 않는다면, 계좌 생성에 대한 테스트가 성공
한 것으로 간주할 생각이다. 이제 테스트 케이스에 

testAccount() 메소드에서 무작정 예외를 무작정 던져버리면 오류가 발생한다. 

public void testAccount() throws Exception {
    Account account = new Account();
    if(accout == null){
        throw new Exception("계좌 생성 실패");
    }
}

public static void main(String[] args){
    AccountTest test = new AccountTest();

    try {
        test.testAccount();
    } catch(Exception e){
        System.out.println("실패")
        return;
    }
    System.out.println("성공");
}

try 구문 안에서 예외가 발생하면 실패라고 출력하고 메인 메소드를 종료한다. 
예외가 발생하면 성공이라고 출력한다. 
최대한 빨리 실패하기
tdd 내에서는 테ㅅ트 자동화를 통해서 개발이 시작된 시점부터 완료될 때까지 가능한 빠른 시점 내에 그리고
자주 실패를 경험하도록 개발이 시작되기도 전에 실패가 발생하는 상황부터
... OK 조건을 사전에 정해두고 빠른 실패를 경험하며, 그 조건을 등대로 삼아
실패 상황을 최대한 빨리 극복하고자 노력한다. 성공한 항목과 실패한 항목이 명화학고
작업해야 하는 부분이 확실하다. 성공에 필요한 조건을 만들고 실패하는 조건 항목ㅇ을 성공시킨다. 

리팩토링을 적용할 부분이 있는지 찾아본다.
한 주기가 끝나기 전에 소스를 정제한다. 보통 이 단계에서 리팩토링 작업을 수행한다. 
정상적으로 동작하는 코드를 수정해서, 사람이 좀 더 이해하기 쉽고 변경이 용이한 구조로
소스코드를 개선하는 작업을 지칭한다. 정상적으로 동작하는 코드를 수정하는 일이
부담스러운 건 사실인데, 자동화된 테스트 케이스가 이미 만들어져 있다면 
두려움이 적어진다. 자동화된 테스트 케이스가 이미 만들어져 있다면
두려움이 적어진다. 여차하면 되돌리기 를 이용하여 마지막으로 테스트가 성공한 시점으로 소스코드를 되돌리면 되기 때문이다. 그래서
자동화된 테스트 케이스를 만들어내는 TDD와 소스를 개선하는 리팩토링은
궁합이 잘 맞는다. TDD에서도 한 주기의 마지막 단계로 정제 단계를 만들어놓고
리팩토링을 권장하고 있다. 리팩토링을 수행하게 되는 정제단계에서는
try {
    test.testAccount();
    test.testGetBalance();
}

대량의 테스트 케이스 항목 관리, 실패 시 메시지 처리, 현재 if 구문을 이용한 예외처리 구조 대신에
좀 더 단순화된 식으로 예상값과 결과값 비교 등이 지원된다면 좀 더 
구조적인 테스트 케이스 작성이 가능해질 것이다. 
사실 충분의 나름의 가치가 있는 일이라 생각되어 TDD의 첫 두 단계를 일부로 조금 돌아왔다.
맨땅에서 시작하는 식으로 말이다. 이제 현재 코드에 제이유닛 단위 테스트
프레임워크를 적용해 볼 생ㄱ가이다. 단위 테스트 프레임워크를 사용하면
어떤 부분이 구조화되고 어떤 장점을 갖게되는지 함께 살펴보자. 