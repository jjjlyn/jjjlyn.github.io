상속에서는 '타입'을 상속받는다는 사실이 가장 중요하다.
클래스는 기존 클래스로부터 가장 중요한 것인 '타입'을 물려받고,
속성이나 동작 따위의 소소한 것들을 물려받는 것.

List<Rectangle> rectangles = new ArrayList<Rectangle>();
rectangles.add(new Rectangle(1,2,3,4));
rectangles.forEach(each -> System.out.println(each););
List<Color> colors = new ArrayList<Color>();
colors.add(new Color(255, 0, 100));
colors.forEach(each -> System.out.println(each));

객체를 바라볼 때 가장 중요한 것은 외부적/ 내부적 관점의 분리다. 
- 내부적 관점 : 객체의 동작을 어떻게 구현할 것인가?
(속성과 행위)
- 외부적 관점: 그 객체를 어떤 객체로 인식할 것이며, 어떻게 다룰 것인가?

만약 어떤 객체가 실제로는 Rectangle(Shape를 상속받았다고 가정)이라고 해도 외부에서 인식하기를 Shape라면 그것은 외부적 관점에서는 Shape이다. 그 실체가 Rectahgle이라는 사실은 그 객체 내부에서나 중요한 것이지 밖에서 그 객체를 사용하는 입장에서는 아무 의미가 없는 것이다. 그 객체는 그냥 Shape일 뿐이다. 오케스트라의 지휘자는 자신의 연주자들이 자신의 지휘에 맞춰 연주할 수 있느냐에 관심이 있지, 그 사람이 바이올린 연주자인지 첼로 연주자인지는 관심이 없다. 그저 지휘만 하면 알아서 연주를 할 것이고, 그것이면 충분하다 그렇다면 외부적 관점인 이 '타입'이 왜 중요한가?

List<Object> objects = new ArrayList<Object>();
objects.add(new Rectangle(1,2,3,4));
objects.add(new Color(255, 0, 100));
objects.forEach(each -> System.out.println(each));

위 코드와 아래 코드는 출력 결과가 같다. Java의 모든 객체는 Object 클래스를 상속받았기 때문이다. 즉 Object는 '타입'이다. 코드 상에서, 극 객체의 외부에서 Object타입으로 불려지게 되는 순간, 둘의 차이는 사라진다. 그리고 그와 함께 중복된 코드들도 함께 사라진다. 만약 서로 다른 종류의 객체가 훨씬 많았더라면 더욱 많은 코드가 사라졌을 것이다. 마치 오케스트라 지휘자가 바이올린 연주하세요, 첼로 연주하세요, 플룻 연주하세요...와 같이 끝나지 않을 것 같은 XXX 연주하세요를 반복하지 않는 것과 같다. 
상속 개념에는 분명 속성과 행위를 내려받아 중복된 코드를 작성하는 것을 방지해 준다는 이점이 있다. 하지만 상속이 진정한 위력을 발휘하는 것은 이런 내부적 관점이 아니라 '타입' 상속이라는 외부적 관점이다. 이 관점이 위력적인 이유는 아무리 실질적으로는 다른 객체들이라도 동일하게 취급할 수 있고, 동일하게 취급되는 순간 유사하긴 하지만 반복적으로 구현되었던 수많은 중복 코드들을 사라지게 만들 수 있다는 것이다. 이런 관점에서 보면 속성이나 행위 따위를 상속받는 것은 매우 소소한 것으로 취급될 수밖에 없다. 
그래서 한번 쯤 더 생각해 볼만한 부분이 바로 인터페이스와 추상 클래스의 개념. 인터페이스는 속성과 실제 구현부라는 실체는 눈 씻고 찾아봐도 없고, 눈으로 보기에는 빈 껍데기에 불과한 API만을 제공한다. 하지만 이 빈껍데기는 '외부적 관점'을 제공해 주고, 이 관점을 이용하는 외부에서 그 객체를 다루는데는 전혀 어려움이 없다. 따라서 같은 인터페이스를 상속 받은 객체들에 대해서는 '같은 관점을 유지'할 수 있고, 같은 관점을 유지할 수 있다는 것은 동일하게 취급할 수 있다는 것이고, 이들 객체에 대해서 별도의 코드들을 각각 작성할 필요가 없다는 것이다. 추상 클래스의 경우 인터페이스에 비해 조금 더 많은 것을 주긴 하지만 물려받은 것에 비해 역시 더 중요한 것은 추상 클래스의 '타입'이다. 이 '타입'이라는 외부적 관점을 이용해서 인터페이스와 같은 위력을 발휘할 수 있다. 내부적 관점에서의 중복 코드도 줄일 수 있다는 장점과 함께...
타입이 같다는 것이 주는 또 하나의 장점은 적절한 시기에 기존의 객체 대신 실질적으로는 다른 객체로 대체시킬 수 있다는 점이다. 이것은 마치 컴퓨터라는 하드웨어에 내부 소프트웨어만 바꿔 실행하면 여러 기능을 하는 범용 컴퓨터와 유사한 개념이다. 이것은 구조적으로 동일하게 구현된 코드 상에서 서로 다른 '로직'을 구현한 '타입'이 같은 객체들을 바꾸어 가며 사용함으로써 소스코드의 양을 줄이면서도 다양한 기능을 수행하게 만들 수 있다는 점. 키보드가 클래스라면, 멤브레인(객체) -> 기계식 키보드(객체)로 교체하여 사용할 수 있다(돌아가는 로직이 물론 다르다. 기계식 키보드가 멤브레인보다 향상된 키보드이기 때문에 더 할 수 있는 것들이 많음ㅋㅋ). 또한 기능의 확장을 위해 다른 코드를 수정하지 않고 동일한 '타입(키보드 타입)'의 새로운 객체 하나만 만들어 넣으면 된다. 이것은 수정이나 기능의 확장을 위해서도 도움이 된다는 것. 
만약 상속을 통해 외부적 관점의 통일성, 즉 '타입'을 상속받지 못하고 단순히 속성과 기능만을 상속할 수 있는 것이었다면 이러한 이점은 생각지도 못할 일이다. 아무리 속성과 기능을 동일한 클래스로부터 상속받았다고 해도 하위 클래스들은 또 서로 엄연히 다른 관점으로 봐야 했을 것이고, 그렇다면 어떤 방법으로도 이들을 다루는 코드들을 '통합'시키기가 어려울 것. 그리고 기존 객체(존나 후진 멤브레인)를 새로운 객체(기계식 키보드)로 간단히 교체한다는 것은 상상하기도 힘들었을 것이다. 상속은, 특히 '타입'의 상속은 중요한 개념이다.
