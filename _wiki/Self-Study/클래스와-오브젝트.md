### 클래스와 오브젝트
#### 클래스와 상속
##### 클래스
코틀린은 주요 생성자에서 프로퍼티를 선언하고 초기화할 수 있는 간결한 구문을 제공한다.
```kotlin
class Person(val firstName: String, val lastName: String, var age: Int){
//...
}
```
일반 프로퍼티와 마찬가지로 **주요 생성자**에 선언한 프로퍼티는 var, val일 수 있다. 생성자가 애노테이션과 가시성 수식어(?)를 가지면 constructor 키워드가 필요하며, 키워드 **앞**에 수식어가 온다.
```kotlin
class Customer public @Inject constructor(name: String){...}
```

보조 생성자는 constructor로 접두사를 붙인다.
```kotlin
class Person{
    constructor(parent: Person){
        parent.children.add(this) // 같은 클래스의 다른 생성자를 호출할 때에는 this 키워드를 사용한다.
    }
}
```

~~가시성 수식어는 public, protected, private 등을 말하는 것 같다.~~

```kotlin
class Person(val name: String){
    constructor(name: String, parent: Person): this(name){
        parent.children.add(this)
    }
}
```

비추상 클래스에 어떤 생성자(주요 또는 보조)도 없을 경우, 인자가 없는 주요 생성자를 생성하면 된다. 이 생성자의 가시성은 public이며, public 생성자를 원하지 않으면 기본 가시성이 아닌 빈 주요 생성자를 선언해야 한다.

```kotlin
class Customer private constructor(){
}
```
```
**주의**: JVM에서 주요 생성자의 모든 파라미터가 기본 값을 가지면, 컴파일러는 추가로 파라미터가 없는 생성자를 생성한다. 이 생성자는 기본 값을 사용하는 주요 생성자를 사용한다.

class Customer(val customerName: String = "")
```

##### 클래스 멤버!!
- 생성자와 초기화 블록
- 함수
- 프로퍼티
- 중첩 클래스와 내부 클래스
- 오브젝트 선언

* 상속
코틀린의 모든 클래스는 공통의 **최상위 클래스**인`Any`를 상속한다. 상위 타입을 선언하지 않으면 `Any`가 기본 상위 타입
`Any`는 `java.lang.Object`가 아님. 
특히 `equals()`, `hashcode()`, `toString()`외에 다른 멤버를 갖지 않는다. 상위 타입을 직접 선언하려면 클래스 헤더에서 콜론 뒤에 타입을 위치시키면 된다.

```kotlin
open class Base(p: Int)
class Derived(p: Int) : Base(p)
```

클래스에 주요 생성자가 있으면, 주요 생성자의 파라미터를 이용해서 기반 타입을 그 자리에서 초기화 할 수 있다...
주요 생성자가 없으면 각 보조 생성자에서 super 키워드로 기반 타입을 초기화하거나 그것을 하는 **다른 생성자**를 호출해야 한다.

```kotlin
class MyView : View {
    constructor(ctx: Context) : super(ctx)
    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)
}
```
이렇게 super 키워드로 기반 타입을 초기화
open 애노테이션은 자바의 final과 반대. open은 다른 클래스가 이 클래스를 상속할 수 있게 허용한다. 기본적으로 코틀린의 **모든 클래스**는 final인데 *Design and document for inheritance or else prohibit it* 을 따른 것이라고 한다.

##### 메서드 오버라이딩
```kotlin
open class Base {
    open fun v() {} // open 키워드를 명시하여 상속 가능
    fun nv() {} // 기본적으로 final이라 상속 불가능
}

class Derived() : Base(){
    override fun v() {} // override로 반드시 메서드 오버리이딩을 명시해야 한다.
}
```
override 애노테이션 명시 안하면 컴파일 실패한다!!
open 애노테이션이 없는 메소드는 override를 사용하든 안 하든 하위클래스에서 동일 메서드를 가져다가 쓸 수 없다.

```kotlin
open class AnotherDerived() : Base(){
    final override fun v(){}
}
```
override가 붙은 멤버는 그 자체가 open인데, 하위 클래스에서 이걸 다시 overriding하는 것을 막고 싶으면 여기서 final 애노테이션을 붙여주면 된다.

##### 프로퍼티 오버라이딩
```kotlin
open class Foo {
    open val x: Int get(){...}
}
class Bar1 : Foo(){
    override val x: Int = ...
}
```
프로퍼티(e.g. val x) 오버라이딩은 메서드 오버라이딩과 유사하게 동작한다. 상위 클래서에 선언된 프로퍼티를 하위 클래스에 재선언하려면 override를 사용해야 하며 호환되는 타입을 사용해야 한다. 선언한 프로퍼티는 initializer를 가진 프로퍼티??나 getter메서드를 가진 프로퍼티로 오버라이딩 할 수 있다. 
또한 val 프로퍼티를 var로는 재정의 가능한데, var을 val로 재정의하는 것은 안됨. val -> var의 재정의를 허용하는 이유는, val 프로퍼티는 근본적으로 getter 메서드를 선언하는데 그것을 var로 overriding하면 추가로 하위 클래스에서 setter 메서드를 선언하기 때문이다. 그래서 var이라고? 뭔 소린지?
~~이해 안되는 부분~~

주요 생성자에 선언한 프로퍼티에도 override 키워드를 사용할 수 있다. 
```kotlin
interface Foo{
    val count: Int
}
class Bar1(override val count: Int) : Foo // 생성자에 선언한 프로퍼티에도 override를 사용할 수 있다
class Bar2: Foo {
    override var count: Int = 0 // var로 재정의 했음. 추가로 하위 클래스에서 setter 메서드를 선언한댄다.
}
```

##### 상위클래스 구현 호출
하위클래스는 super 키워드를 이용해서 상위클래스의 함수와 프로퍼티의 접근 구현을 호출할 수 있다?

```kotlin
open class Foo {
    open fun f() { println("Foo.f()") }
    open val x: Int get() = 1
}

class Bar : Foo() {
    override fun f(){
        super.f()
        println("Bar.f()") // Foo.f()와 Bar.f()가 둘 다 출력될 것
    }
    
    override val x : Int get() = super.x + 1 // super 키워드로 상위 클래스의 프로퍼티에 접근하여 프로퍼티 구현 값을 가져왔다
}
```

내부 클래스는 `super@Outer`와 같이 외부 클래스의 **이름**을 이용해서 외부 클래스의 **상위 클래스**에 접근할 수 있다.

```kotlin
class Bar: Foo(){
    override fun f(){ //... }
    override val x: Int get() = 0
    
    inner claass Baz {
        fun g(){
            super@Bar.f() // Foo의 f() 구현
            println(super@Bar.x) // Foo의 x의 getter를 사용
        }
    }
}
```

##### Companion Object
코틀린은 자바와 C#과 달리 클래스에 정적 메서드가 없다. 클래스 인스턴스 없이 클래스 내부에 접근해야 하는 함수를 작성해야 한다면(e.g. 팩토리 메서드), 그 클래스에 속한 오브젝트 선언의 멤버로 함수를 작성할 수 있다. 더 구체적으로 Companion Object 를 클래스 안에 선언하면, 정적 메서드를 호출하는 것과 동일한 구문으로 멤버를 호출 할 수 있다. 

##### Getters와 Setters
initializer, getter, setter는 선택사항이다. 프로퍼티 타입은 initializer(또는 getter)의 리턴 타입에서 유추할 수 있으면 생략 가능하다. 
사실 코틀린은 기본적으로 프로퍼티 선언 시 getter, setter가 자동으로 생성된다. 여기서 굳이 커스텀 getter, setter를 선언할 경우에는 역시 선언할 수 있다. 

```kotlin
var allByDefault: Int? // 에러: initializer 필요, 기본 getter와 setter 적용
var initialized = 1 // Int 타입을 갖고, 기본 getter와 setter 포함
```

읽기 전용 프로퍼티 선언은 setter를 허용하지 않는다.
```kotlin
val simple: Int? // Int 타입이고, 기본 getter, 생성자에서 초기화해야 한다
val inferredType = 1 // Int 타입이고 기본 getter
```

일반 함수처럼 프로퍼티 선언에 커스텀 접근자를 작성할 수 있다... 접근자(?)
```kotlin
val isempty: Boolean get() = this.size == 0
```

커스텀 setter는 다음과 같다.
```kotlin
var stringRepresentation: String get() = this.toString
                                 set(value) {
                                    setDataFromString(value)
                                }
```
setter 파라미터의 이름을 value로 하는 것은 관례라고 한다. 

```kotlin
val isEmpty get() = this.size == 0 // boolean type
```
이렇게 type inference에 의해서 자동 형 추론이 가능해서 타입을 명시해주지 않아도 되는 경우도 있음

프로퍼티의 기본 구현을 바꾸지 않고 애노테이션을 붙이거나 접근자의 가시성(e.g. private, public 등)을 바꾸고 싶으면 몸체없는 접근자를 정의하면 됨

```kotlin
var setterVisibiltiy : String = "abc"
    private set // setter를 private으로 설정하고 싶다. 그러나 기본 구현을 그대로 가져간다.
var setterWithAnnotation : Any? = null
    @Inject set // setter에 @Inject 애노테이션 적용
```

cf) 프로퍼티와 필드의 차이
코틀린의 클래스는 필드를 가질 수 없다. (프로퍼티는 갖는다) 여기서 프로퍼티란 getter, setter 등을 갖고 있는 java bean과 같은 개념이다. 프로퍼티는 문자 그대로 '속성'의 개념... 

##### 지원(Backing) 필드
커스텀 접근자를 사용할 때 필드가 필요할 때가 있다? 이런 목적으로 코틀린은 field 식별자로 접근할 수 있는 지원 필드를 자동으로 제공한다.
```kotlin
var counter = 0
    set(value) {
        if(value >= 0) field = value
    }
```
`field` 식별자가 바로 `Backing 필드`다. **이 변수는 getter와 setter안에서만 사용할 수 있다고 한다.**  저 필드가 실제 위에서는 counter라는 필드에 assign을 하는 것. 보통 커스텀 getter, setter를 새로 정의할 때 클래스 내부에서 필드를 가질 수 없으니 field라는 `Backing 필드`를 통해 임시적으로 접근할 수 있게 해주는 것인듯...

field 식별자는 오직 프로퍼티의 접근자에서만 사용할 수 있다. ~~무슨 소리인지 모르겠당~~ 접근자의 기본 구현을 적어도 한 개 이상 사용하거나 또는 커스텀 접근자에서 field 식별자로 지원 필드에 접근한 경우, 프로퍼티를 위한 지원 필드를 생성한다???

```kotlin
val isEmpty: Boolean get() = this.size == 0
// 이 경우에는 지원 필드가 없다? ㅇㅇ field 변수가 없자나
```

cf) 컴파일 타임에 값을 알 수 있는 프로퍼티는 `const`라는 키워드를 사용하면 된다.
```kotlin
const val SUBSYSTEM_DEPRECATED: String = "This subsystem is deprecated"
// 컴파일 타임에 값을 알 수 있음
```

##### Backing Property
"자동 backing field" 방식이 맞지 않을 때 backing property로 대신할 수 있다.
```kotlin
private var _table: Map<String, Int>? = null
public val table: Map<String, Int> get(){
    if(_table == null){
        _table = HashMap()
    }
    return _table ?: throw AssertionError("Set to null by another thread")
}
```
지원 프로퍼티는 여기서 _table을 말하는 것 같다. 마치 자바에서 singleton 패턴을 보는듯한... 기본적으로 getter과 setter를 가진 private 프로퍼티에 접근하면 함수 호출에 따른 오버헤드가 발생하지 않도록 최적화 한다고??? ~~이것 역시 뭔 소린지 몰라~~

* 컴파일 타임 상수
아까 cf) 에서 언급했던 거네. 컴파일 시점에 알아야 할 프로퍼티 값을 `const` 수식어를 이용해서 컴파일 타임 상수로 표시할 수 있다. 다음 조건을 충족해야 함
- 최상위 또는 Companion Object의 멤버(?)
- String이나 기본 타입 값으로 초기화
- 커스텀 getter 안됨


* 초기화 지연(late-initialized) 프로퍼티
보통 null 안 갖는 타입으로 선언한 프로퍼티는 생성자에서 초기화 해야 한다. 
`lateinit`는 (주요 생성자에 포함되지 않고 프로퍼티가 custom getter, setter를 갖지 않을 때만) 클래스 몸체에 선언한 `var` 프로퍼티에 사용할 수 있다. 코틀린 1.2부터는 최상위 프로퍼티와 로컬 변수에 사용할 수 있다. 프로퍼티나 로컬 변수의 타입은 **not null* 이어야 하고 **기본 타입이면 안 된다.** 
`lateinit` 프로퍼티를 초기화하기 전에 접근하면 특수한 익셉션을 발생한다. 이 익셉션은 접근한 프로퍼티가 아직 초기화되지 않았다는 것을 명확하게 식별한다. 

##### lateinit var 초기화 여부 검사
`lateinit var`을 이미 초기화했는지 확인하려면 그 프로퍼티에 대한 참조변수에 `.isInitialized`를 사용한다. 

```kotlin
if(foo::bar.isInitialized){
    println(foo.bar)
}
```

* 인터페이스의 구현
```kotlin
class Child : MyInterface {
    override fun bar(){
    }
}
```
클래스나 오브젝트? 여기서 오브젝트의 개념이 뭐냐? 한 개 이상의 인터페이스를 당연히 구현할 수 있다. 

* 인터페이스의 프로퍼티
인터페이스에 프로퍼티를 선언할 수 있다. 인터페이스에 선언한 프로퍼티는 추상이거나 또는 접근자를 위한 구현(?)(getter, setter 등)을 제공하기도 한다. 인터페이스의 프로퍼티는 backing field를 가질 수 없다...

```kotlin
interface MyInterface {
    val prop: Int // 추상
    val propertyWithImplementation: String get() = "foo"
    fun foo() {
        print(prop)
    }
}

class Child: MyInterface {
    override val prop: Int = 29 // 상속 후 초기화
}
```

* 가시성 수식어(접근제한자)
자바에서는 접근제한자라고 하는데 코틀린에서는 더럽게 이상하게 표현하네. 
- private : 그 선언을 포함한 파일 혹은 클래스 안에서만 접근 가능
- protected : 최상위 선언(top-level)에 사용할 수 없다. private과 같지만 같은 파일이 아니더라도 **자식 클래스**에서는 접근 가능하다. 
- internal : 같은 모듈 안에서 접근 가능. 기본적으로 java의 default와 비슷하지만 같다고 볼 수는 없음. 클래스나 변수는 같은 모듈에 한해서는 접근할 수 있게 해주는 인자인데 여기서 아무도 모듈의 뜻을 설명하지 않고 있음;; 코틀린의 **모듈**은 자바와는 약간 차이가 있다. 자바에서 모듈은 기능이 비슷한 클래스들의 집합체를 말하고, 코틀린에서는 동일한 컴파일의 집단을 의미한다. 그런데 더 뭔 개소린지 모르겠네. 그냥 같은 프로젝트 내에서는 internal 제한자에 대해 접근이 가능하다고 보면 된다. 
- public : 어디에서나 접근 가능
여기서 자바와 차이점은 수식어를 지정하지 않을 경우 기본 가시성은 **public**이라는 점이다. default가 public이었어서 키워드를 보지 못했던 것이었음
cf) public 접근 제한을 가진 것들을 다른 패키지에서 사용하려는 경우에는 import를 해서 사용할 수 있다.
cf) 로컬 변수, 로컬 함수, 로컬 클래스(?)는 접근 제한자를 가질 수 없다...

```kotlin
package foo
private fun foo() {}
public var bar: Int = 5
    private set // setter는 이 파일.kt 에서만 접근 가능
internal val baz = 6 // 선언한 클래스를 볼 수 있는 모듈 안의 모든 클라이언트가 볼 수 있다. 
```
코틀린은 자바와 달리 외부 클래스에서 내부 클래스의 private 멤버를 볼 수 없다. ~~사실 외부 클래스에서 내부 클래스 private 멤버를 볼 수 있는지도 몰랐다~~ `protected` 멤버를 오버라이딩 할 때 가시성을 명시적으로 지정하지 않으면, 오버라이딩한 멤버도 그대로 `protected`의 가시성을 갖는다. 

```kotlin
open class Outer {
    private val a = 1 // 같은 클래스 혹은 파일 내부에서만 접근 가능
    protected open val b = 2 // 자식 클래스에서까지는 접근 가능
    internal val c = 3 // 같은 모듈 안에서는 접근 가능... 
    val d = 4 //기본적으로 public이고 어디서나 접근 가능
    
    protected class Nested { // inner class
        public val e: Int = 5 // inner class의 멤버 변수는 outer class에서 접근 불가
    }
}

class Subclass : Outer(){ // Outer 클래스를 상속 받았음 
    // a는 접근 불가 (private이라 접근 불가)
    // b, c, d 접근 가능 (protected 멤버 변수는 자식 클래스에서 접근 가능, c, d는 같은 모듈... 접근 가능. 사실 d는 어디서나 접근 가능
    // Nested와 e는 접근 가능. (상속 받았으니까 Nested 접근 가능, e도 접근 가능하다고 하네...)
    override val b = 5 // protected 멤버를 오버라이딩 할 때 따로 접근 제한자 지정을 안해주면 그대로 protected로 지정된다.
}

class Unrelated(o: Outer){
    // o.a, o.b 접근 불가 (private, protected는 상속받지 않으면 private과 별 반 다를 것 없음)
    // o.c, o.d는 같은 모듈이라 접근 가능(같은 프로젝트 내부라 internal 접근 가능, public은 어디서나 접근 가능)
    // Outer.Nested 접근 불가, Nested::e 역시 접근 불가(Outer.Nested는 Outer를 상속받지 않았기 때문에 접근 불가능하고 그 내부 프로퍼티인 변수 b에도 접근할 수 없다.) 
}
```

* 확장(Extensions)
코틀린은 클래스 상속이나 데코레이터 같은 설계 패턴없이 클래스에 새로운 기능을 확장할 수 있는 기능을 제공한다?
클래스를 상속하여 기능을 확장하거나, 모듈 내 코드나 패턴을 조합하거나 유틸리티로 새로 정의하여 사용하곤 한다. 코틀린에서는 확장을 통해 간단하게 객체의 함수나 프로퍼티를 임의로 확장 정의하여 사용할 수 있다. 

##### Extension function의 예
String 타입에 `hello()`라는 이름의 확장 함수를 구현해보자
```kotlin
fun String.hello() : String {
    return "Hello, $this"
}

fun main(args: Array<String>){
    val whom = "cwdoh"
    println(whom.hello())
}

// Result: Hello, cwdoh
```

자바 decompile 버전
```java
public final class ExtensionKt {
    @NotNull
    public static final String hello(@NotNull String $receiver){
        Intrinsics.checkParameterIsNotNull($receiver, "$receiver");
        return "Hello" + $receiver;
    }
    
    public static final void main(@NotNull String[] args){
        Intrinsics.checkParameterIsNotNull(args, "args");
        String whom = "cwdoh";
        String var2 = hello(whom);
        System.out.println(var2);
    }
}
```

확장 대상(receiver)인 String을 인자로 받는 static final로 메소드가 생성된다. 이는 클래스 자체가 확장된 것이 아니라, **정적 메소드** 형태로 코드가 생성되었으므로, 객체 멤버 접근에 제한이 존재할 수 있다는 뜻으로 해석할 수 있다. _Extensions are resolved statically_
> Extension은 실제로 클래스를 상속/ 수정하는 것이 아니다. 클래스에 새 멤버를 삽입하는 것이 아니라 단순히 해당 타입의 변수에 dot(.)을 기반으로 호출 가능한 함수를 **생성**한다. 
> Extension이 리시버 타입에 의한 가상 함수가 아니라 **정적**으로 처리된다는 점을 강조하고 싶다. 이는 호출되는 확장 함수는 표현식의 타입에 따라 결졍된다는 것을 의미한다.

```kotlin

open class C

class D: C()

fun C.foo() = "c" // 확장 함수
fun D.foo() = "d" // 확장 함수

fun printFoo(c: C) {
    println(c.foo())
}

class Demo {
    fun run(){
        printFoo(D())
    }
}
```

일반적인 객체의 멤버라면 실제로 참조하고 있는 자신의 타입을 기반으로 함수를 호출하겠지만(여기에서는 D 타입이 파라미터로 들어가면 D 타입을 받는 함수가 호출되어야 한다는 의미. 그러나 결과적으로는 C 타입을 받는 함수가 호출된다. 이유는 정적으로 처리되기 때문이라고 한다...), Extension의 경우 다음과 같이 코드가 생성된다.

```java
public final class Demo{
    public final void run(){
        DemoKt.printFoo((C)(new D()));
    }
}

public final class DemoKt {
    @NotNull
    public static final String foo(@NotNull C $receiver){
        Intrinsics.checkParameterIsNotNull($receiver, "$receiver");
        return "c";
    }
    
    @NotNull
    public static final String foo(@NotNull D $receiver){
        Intrinsics.checkParameterIsNotNull($receiver, "$receiver");
        return "d";
    }
    
    public static final void printFoo(@NotNull C c){
        Intrinsics.checkParameterIsNotNull(c, "c");
        String var1 = foo(c);
        System.out.println(var1);
    }
}
```

아직 이해를 못하겠다...


즉, printFoo()에서 D의 객체를 생성하여 전달하기 때문에 D.foo()를 호출하는 것 같지만 Extension은 정적으로 처리되는 이유로(??) printFoo()에서 사용하는 타입인 C.foo()를 호출하게 된다. 

#### Extension보다 멤버가 우선이다. 
이미 클래스에 동일한 시그니처를 가지는 멤버가 있을 때에도 Extension을 정의할 수 있긴 하다. 그런데 실행은 멤버가 우선이다...

```kotlin
class Person{
    fun hello(){ println("hello!")}
}

fun Person.hello(){ println("HELLOOOOOOOOOOOOO") }

fun main(args: Array<String>){
    Person().hello()
}

// Result: hello!
``` 
나중에 자바로 디컴파일 해보면 또 정적 함수로 Extension이 생기긴 하는데 이미 동일한 시그니처의 **멤버**가 존재하기 때문에 이를 호출하도록 코드가 생성된다. 
> 이렇게 멤버에 대한 우선 순위가 적용되는 것은 별도의 에러가 발생하지 않기 때문에 주의해야 할 필요가 있겠다. 물론 시그니처가 다를 경우에는 당연히 해당되는 사항이 아니다.
