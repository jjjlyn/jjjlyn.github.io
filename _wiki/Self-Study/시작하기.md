### 시작하기
<br>

#### 기초 구문

##### 함수 정의 
* 식 몸체(expression body)를 사용하고 리턴 타입을 추론
```kotlin
fun sum(a: Int, b: Int) = a + b
```
* 의미없는 값을 리턴하는 함수(이때는 리턴 타입 생략 가능)
```kotlin
fun printSum(a: Int, b: Int): Unit {
    println("sum of $a and $b is ${a+b}"
}
// 생략 표현
fun printSum(a: Int, b: Int){
    println("sum of $a and $b is ${a+b}"
}
```

##### 로컬 변수 정의(한 번만 할당가능한 읽기 전용 변수일 경우)
```kotlin
val a: Int = 1
val b = 2 // Int 타입으로 추론
val c: Int // 초기화 하지 않을 거면 타입 필요하다
c = 3 // 나중에 할당
```

변경 가능 변수일 경우
```kotlin
var x = 5 // Int 타입 추론
x += 1
```

##### 조건 식 사용
```kotlin
fun maxOf(a: Int, b: Int) = if(a > b) a else b
```
if는 식(expression)으로 값을 리턴한다. 그래서 **삼항연산자**가 없다. 일반 if로 동일하게 할 수 있다.
```kotlin
// 전통적인 용법
var max = a
if(a < b) max = b
// else 사용
var max: Int
if(a > b){
    max = a
} else {
    max = b
}

// kotlin에서는
var max = if(a > b) a else b
// 이런 식으로 if가 식으로 값을 리턴하는 방식
```
문장이 아닌 식으로 if를 사용하면(예를 들어 식의 값을 리턴하거나 변수에 값을 할당), else 브랜치를 가져야 한다. 

cf) When은 Switch에 해당되는 것!!!
when은 특정 브랜치의 조건을 충족할 때까지 **순차적으로** 모든 브랜치의 인자가 일치하는지 확인한다. when은 **식**이나 **문장**으로 사용할 수 있다. 식으로 사용하게 되면 if처럼 각 브랜치(블록)에서 **가장 마지막 식의 값**이 브랜치의 값이 된다.


```kotlin
when(x){
    0, 1 -> print("x==0 or x==1") // 여러 경우를 동일한 방법으로 처리할 경우
    else -> print("otherwise")
}
```
브랜치 조건으로 (상수 뿐 아니라) 임의의 식도 사용할 수 있다.


```kotlin
when(x){
    parseInt(s) -> print("s encodes x") // 변수 s를 parseInt()한 값과 일치할 때
    else -> print("s does not encode x")
}
```

in, !in, 범위, 콜렉션 사용해서 값을 검사할 수도 있다.
```kotlin
when(x){
    in 1..10 -> print("x is in the range")
    in validNumbers -> print("x is valid")
    !in 10..20 -> print("x is outside of the range")
    else -> print("none of the above")
}
```

for는 iterator를 제공하는 모든 것에 대해 **반복**을 수행한다.
- iterator()
- next()
- hasNext()
이 세 함수는 모두 operator(?)로 지정해야 한다. 
배열에 대한 for 루프는 iterator 객체를 생성하지 않는 **인덱스 기반 루프**로 컴파일 된다. 인덱스를 이용해서 배열이나 리스트를 반복할 수 있음
```kotlin
for(i in array.indices){
    print(array[i])
}
```

##### 리턴과 점프
- return : 가장 가깝게 둘러싼 함수에서 리턴
- break : 가장 가깝게 둘러싼 루프를 끝낸다
- continue : 가장 가깝게 둘러싼 루프의 다음 단계를 진행한다

```kotlin
val s = person.name ? : return // person.name이 없고 null일 경우에는 그냥 return 해라
```

break와 continue 라벨
코틀린의 모든 식에 label을 붙일 수 있다. 라벨은 `@` 부호 뒤에 식별자가 붙는 형식으로, 식 앞에 라벨을 위치시켜 라벨을 붙인다. 

```kotlin
loop@ for (i in 1..100){
    for (j in 1..100){
        if (...) break@loop
    }
}
```

라벨로 한정한 break는 해당 라벨이 붙은 루프 이후로 실행 지점을 점프한다. (가장 가깝게 둘러싼 루프를 끝내는게 아니라 라벨 붙은 루프를 끝낸다는 뜻)
continue도 마찬가지로 라벨 붙은 루프의 다음 단계를 진행한다.

라벨에 리턴하기
한정한 return을 사용하면 바깥 함수로부터 리턴할 수 있다. 가장 중요한 용도는 람다 식에서 리턴하는 것. 
```kotlin
fun foo(){
    ints.forEach{
        if(it == 0) return // forEach에서 아예 빠져나와서 foo()의 caller로 바로 return
        print(it)
    }
}
```

return 식은 가장 가깝게 둘러싼 **함수**(아까는 fun foo())에서 리턴한다. 람다 식에서 리턴하고 싶다면(ints.forEach ~~) 람다 식에 라벨을 붙여서 return을 한정해야 한다. 

```kotlin
fun foo(){
    ints.forEach lit@{
        if(it == 0) return@lit // ints.forEach { ~~ }에서 빠져나오고 fun foo()의 아래 코드들은 계속 execute된다는 의미인 것 같다...
        print(it)
    }
}
```

```kotlin
fun foo(){
    ints.forEach {
        if(it == 0) return@forEach
        print(it)
    }
}
```
이런식으로 라벨은 **람다를 전달한 함수와 같은 이름**을 갖는다. 

람다 식 대신 익명 함수를 사용해도 된다. 익명 함수에서 return 문장은 익명 함수 자체에서 리턴한다. 
```kotlin
fun foo(){
    ints.forEach(fun(value: Int){
        if(value == 0) return // 익명 함수 호출에 대한 로컬 리턴!!
        print(value)
    })
}
```

```kotlin
return@a 1
```
이런 식은 라벨@a(a라는 명칭을 가진 fun)에 1을 리턴하는 것을 의미한다.












##### null 가능 값 사용과 null 검사
null 값이 가능할 때 반드시 레퍼런스를 **명시적으로** null 가능(nullable)으로 표시해야 한다. 아래 코드가 `str`이 정수를 갖지 않으면 null을 리턴한다고 할 때
```kotlin
fun parseInt(str: String): Int? {
//...
}
```

```kotlin
fun printProduct(arg1: String, arg2: String){
    val x = parseInt(arg1) 
    val y = parseInt(arg2)
    
    if(x != null && y != null){
        print(x * y)
    } else {
        println("either '$arg1' or '$arg2' is not a number)
    }
}
```

##### 타입 검사와 자동 변환 사용
is 연산자는 식이 타입의 인스턴스인지 검사한다. 불변 로컬 변수나 프로퍼티가 특정 타입인지 검사할 경우 타입을 변환할 필요가 없다. 
```kotlin
fun getStringLength(obj: Any): Int?{
    if(obj is String){
        return obj.length
    }
    return null // 타입 검사 블록 밖에서 'obj'를 자동으로 'String'으로 변환
}
```
또는
```kotlin
fun getStringLength(obj: Any): Int?{
    if(obj !is String) return null
    return obj.length
}
```

```kotlin
fun getStringLength(obj: Any): Int?{
    if(obj is String && obj.length > 0){
        return obj.length
    }
    return null
}
```

```kotlin
val items = listOf("apple", "banana", "kiwi")
for(item in items){
    println(item)
}
```

```kotlin
val items = listOf("apple", "banana", "kiwi")
for(index in items.indices){
    println("item at $index is ${items[index]}")
}
```

```kotlin
val items = listOf("apple", "banana", "kiwi")
var index = 0
while(index < items.size){
    println("item at $index is ${items[index]})
    index++
}
```

```kotlin
fun describe(obj: Any): String = 
    when(obj) {
        1 -> "One"
        "Hello" -> "Greeting"
        is Long -> "Long"
        !is String -> "Not a string"
        else -> "Unknown"
    }
```

```kotlin
val x = 10
val y = 9
if(x in 1..y+1){
    println("fits in range")
}
```

!in 연산자를 사용해서 숫자가 범위를 벗어나는지 검사
```kotlin
val list = listOf("a", "b", "c")

if(-1 !in 0..list.lastIndex){
    println("-1 is out of range")
}
if(list.size !in list.indices){
    println("list size is out of valid list indices range too")
}
```

```kotlin
for(x in 1..5){
    print(x)
}
```

```kotlin
for(x in 1...10 step 2){
    print(x) // 1 3 5 7 9
}

for(x in 9 downTo 0 step 3){
    print(x) // 9 6 3 0
}
```

```kotlin
for(item in items){
    println(item)
}
```

```kotlin
when{
    "orange" in items -> println("juicy")
    "apple" in items -> println("apple is fine too")
}
```

