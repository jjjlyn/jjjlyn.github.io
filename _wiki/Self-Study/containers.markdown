**커널**
OS의 가장 중심부로서, 항상 메모리에 상주하고 있다. 하드웨어와 소프트웨어 컴포넌트 상호작용을 용이하게 한다. 메모리 핸들링, 입출력 요청 처리 등을 담당한다. 메모리의 특정 부분에 로딩되어 프로세스 실행, 하드 디스크 관리, 인터럽트 처리를 수행한다(커널 공간에 위치해 있음). 반면 사용자 어플리케이션 프로그램은 사용자 공간에 위치한다. 이렇게 공간을 분리해 놓는 이유는 사용자 데이터와 커널 데이터가 서로 충돌(방해)작용을 한다면, 안정성/속도 저하의 위험이 있기 때문. 
프로세스(실행 중인 프로그램)이 커널로 서비스를 요청하면, 이는 System Call을 야기한다. 브라우저가 OS로 IP 주소를 요청할 때 이런 시스템콜을 발생시킨다. 

- 도커는 User Space에서 돌아감 -> Docker CLI, Docker Daemon
Docker Demon이 Background에서 돌아감 -> child process를 실행시킨다. 도커는 컨테이너를 생성하고, 이 컨테이너 안에서 프로세스가 돌아간다.
도커가 없을 경우에 하드웨어 가상머신을 사용한다. 가상머신은 OS와 타프로그램이 설치될 수 있는 가상 하드웨어를 제공함. 그러나 가상머신에 OS전체를 설치한 후, 내가 필요로 하는 소프트웨어 전부를 설치해야 하기 때문에 오버헤드가 크다. 
도커 컨테이너는 가상머신이 아니다. 도커 컨테이너 안에서 돌아가는 프로세스는 호스트의 리눅스 커널과 직접 상호작용할 수 있다. OS와 컨테이너 안에서 실행되고 있는 프로그램 사이에 추가적인 계층(레이어)가 없기 때문이다. 따라서 가상머신 혹은 쓸데없는 소프트웨어 설치 등으로 인해 낭비되는 자원이 없음. 도커는 OS에 이미 구축되어 있는 컨테이너 기술을 사용할 수 있도록 도와주는 역할을 한다. 
도커는 컨테이너 기술을 제공하는 것이 아니라, 이를 쉽게 사용할 수 있도록 도와주는 보조적인 역할을 하는 툴이다. 
도커가 없으면 내가 설치한 어플리케이션들은 또 다른 어플리케이션에 의존적이기 때문에, 예를 들어 음악 플레이어와 브라우저가 파이썬(another application)에 의존적이라면, 여기 저기서 의존적이여서 엉키는 상황이 발생한다. 
도커는 이런 상황을 방지하고자, 모든 것을 이미지와 컨테이너로 감싸서 isolate 시킨다.

현재까지 도커는 리눅스에서는 그냥 돌아가고, OS X와 윈도우 환경에서는 한 개의 가상 머신 위에서 돌아간다. 가상머신보다 도커가 낫다는 소리는, 가상머신에 한 개의 어플리케이션을 설치하려고 그 복잡한 과정을 거치는 것보다 도커가 낫다는 의미다. 도커와 가상머신은 대립되는 개념이 아니라 보완적인 개념이다. 이런 식으로 일을 처리하면 한 개의 어플리케이션을 실행할 때마다 여러 개의 가상머신을 설치해야 된다. 
