4.1.2. 변수 초기화
* 변수 선언은 최상위(클래스 외부), 클래스 내부, 함수 내부에 선언
* 최상위 레벨이나 클래스의 멤버 변수는 선언과 동시에 초기화 해주어야 한다.
* 함수 내부의 지역 변수는 선언과 동시에 초기화하지 않아도 된다. 초기화한 후 사용할 수 있다.

val topData1: Int
var topData2: Int

class User{
    val objData1: String // error
    var objData2: String // error -> 최상위 레벨이나 클래스 멤버 변수는 선언과 동시에 초기화 해주어야 한다.
    
    fun some(){
        val localData1: Int // 함수 내부 지역 변수는 선언과 동시에 초기화 할 필요 없다. 그러나 초기화를 언젠가는 해야 사용할 수 있음.
        var localData2: String
        
        println(localData1)
        
        localData2="hello"
        println(localData2)
        }
    }
    
4.1.3. null이 될 수 있는 변수와 null
* 코틀린에서는 null을 대입할 수 없는 변수와 있는 변수로 구분
* 변수에 null 값을 대입하려면 타입에 ? 기호를 이용하여 명시적으로 null이 될 수 있는 변수로 선언

val nullableData1: String? = null
var nullableData2: String? = null

fun main(args: Array<String>){
    nullableData2 = "hello"
}

4.1.4. 상수변수 선언
* 코틀린에서 변수는 property이다.
* val로 선언한 변수의 초깃값을 변경할 수는 없지만, 또 일반적인 상수 변수와는 차이가 있다. 
* const라는 예약어를 이용하여 상수 변수를 만든다.
* 최상위 레벨로 선언할 때만 const예약어를 사용가능

const val myConst: Int = 10

class MyClass {
}

fun some(){
}

fun sum(a:Int, b:Int): Int{
    return a+b
}

매개변수에는 var, val을 선언할 수 없다. 매개변수는 기본적으로 val이 적용한다. 의미있는 반환값이 없을 때는 Unit으로 명시
매개변수를 선언할 수는 없고, 그냥 default가 val

fun sum(a:Int, b:Int): Unit{
}

fun sum(a:Int, b:Int){
}

함수 내에 함수 선언 가능하다. 
fun sum(a:Int, b:Int) : Int {
    var sum = 0
    fun calSum(){
        for(i in a..b){
            sum += i
        }
    }
    calSum()
    return sum
}

fun some(a:Int, b:Int): Int {
    return a+b
}

fun some(a:Int, b:Int): Int = a+b
fun some(a:Int, b:Int) = a+b

fun some(a: String){
    println("some(a: String) call...")
}

fun some(a: Int){
    println("some(a: Int) call...")
}

fun some(a: Int, b: String){
    println("some(a: Int, b: String) call...")
}

fun sayHello(name: String = "kkang"){
    println("Hello!" + name)
}

중위표현식
infix(중위 표헌식)이란 연산자를 피 연산자의 중간에 위치시킨다는 개념

infix fun Int.myFun(x: Int) : Int {
    return x*x
}

class FunClass {
    infix fun infixFun(a: Int){
        println("infixFun call...")
    }
}

fun main(args: Array<String>){
    val obj = FunClass()
    obj.infixFun(10)
    obn infixFun 10
    
fun <T> varagsFun(a1: Int, varag array:T){
    for(a in array){
        println(a)
    }
}

fun main(args: Array<String>){
    varagsFun(10, "Hello", "World")
    varagsFun(10, 20, false)
    }

tailrec은 꼬리재귀(tail reculsive)라는 의미로, 추가적인 연산이 없이 자기 스스로 재귀적으로 호출하다가 어떤 값을 리턴하는 함수를 의미한다. 자신만 반복적으로 호출하는 재귀함수는 while과 같이 loop를 사용하는 코드로 변환할 수 있다. 이렇게 변환하면 좋은 점은 재귀함수가 호출되면서 소비되는 스택을 아낄 수 있다는 점이다. 루프는 동일한 결과를 출력하면서 재귀함수보다 더 적은 자원을 사용하게 된다.
코틀린에서는 tailrec 키워드가 있다. 이 키워드가 붙은 함수가 꼬리재귀 함수라면 코드가 컴파일 될 때 루프를 사용한 코드로 변경된다. 재귀와 꼬리재귀 함수의 차이점에 대해 알아보고 tailrec키워드로 함수들이 어떻게 컴파일 되는지 알아보자. 재귀함수와 꼬리재귀(tail recursive)
아래의 fractional은 재귀함수로 구현되었고, 재귀함수가 스스로 자신만을 호출하다 값을 리턴하는 구조이기 때문에 꼬리재귀(tailrec)라고 할 수 있음

fun factiorial(n: Int, acc: Int): Int{
    return if(n<=0){
        acc
    } else {
        factorial(n-1, n*acc)
        }
    }
    
fun main(args: Array<Strign>){
    println("factorial(10) : ${factorial(10, 1)})
}

반면에 아래 재귀함수는 꼬리재귀 함수가 아니다. 자신만을 반복적으로 호출하지 않고 1+재귀함수와 같은 추가적인 연산을 수행한다. 

fun factorial_plus_n(n: Int, acc: Int): Int{
    return if(n<=0){
        acc
    } else {
        1 + factorial_plus_n(n-1, n*acc)
    }
}

1+재귀함수와 같은 추가적인 연산을 수행한다. 그렇기 때문에 꼬리 재귀함수가 아니다. 1+재귀함수와 같은 추가적인 연산을 수행한다.

tailrec 사용방법
꼬리재귀인 factorial 함수에 tailrec이라는 키워드를 붙이면 컴파일러가 꼬리재귀를 루프를 이용한 코드로 변경해준다. 꼬리재귀인 factorial 함수에 tailrec이라는 키워드를 붙이면 컴파일러가 꼬리재귀를 루프로 이용한 함수로 변경해준다. 하지만 꼬리재귀가 아닌 함수에 tailrec키워드를 부텨도 루프로 변환하게 되면 재귀함수가 호출되면서 소비되는 스택을 아낄 수 있다는 점이다. 재귀함수가 호출되면서 소비되는 스택을 아낄 수 있다고?
이걸 하지만 꼬리 재귀가 아닌 함수에 tailrec키워드를 붙여도 루프 코드로 변경되지 않는다. 일반 재귀함수에 tailrec이 붙은 코드를 컴파일 해보면 tailrec키워드가 붙었지만 꼬리재귀가 아니라는 경고가 발생한다.

바이트코드 비교
실제로 어떻게 컴파일되는지 확인해보기 위해 바이트 코드를 비교해보자.
먼저 꼬리재귀이지만 tailrec키워드가 붙지 않은 함수
fun factiorial(n: Int, acc: Int): Int {
    return if(n <= 0){
        acc
    } else {
        factorial(n-1, n*acc)
    }
}

바이트 코드는 아래와 같고, 함수 내부에 INVOKESTATIC main/kotlin/Kotlin1Kt.factorial (||)|를 호출하는 코드가 있다. 바이트 코드는 잘 모르지만, 재귀적으로 함수가 계속 호출될 것으로 예상이 됨.

tailrec fun sum(n: Int): Int {
    if(n <= 0) return n
    else return n + sum(n-1)
}

tailrec fun sum2(n: Int, result: Int = 0): Int {
    if(n <= 0) return result
    else return sum2(n-1, n+ result)
}

public static final int sum(int n){
    return n<=0 ? n : n + sum(n-1);
} => 꼬리 재귀함수가 아니라서 java compile될 때 루프로 변환되지 않는다.

가변인자는 개수가 정해지지 않은 인자를 말한다. 예를 들어 아래 코드는 인자가 1개로 정해져 있다. 그렇기 때문에 인자를 2개로 늘리려면 코드를 변경해야 한다. 

fun printString(string: String): Unit{
    println(string)
}

가변인자 사용 방법
가변인자는 인자의 개수를 유동적으로 받을 수 있다. 가변인자를 사용한다면 인자의 개수가 변경된다고 해도 코드를 변경하지 않아도 된다. 아래 코드는 함수에 가변인자를 적용한 예제다. 인자 앞에 vararg를 선언하면 코틀린은 이 변수를 가변인자로 취급한다.

static? static이 선언된 변수는 클래스의 모든 객체가 공유 가능하다. 클래스 변수라고도 한다. new로 클래스 객체 생성없이 호출 가능

final static double PI = 3.14;

const val PI: Double= 3.14

코틀린에서 요구사항
최상위 또는 member of an object 선언 또는 Companion Objects
형태의 값 String 또는 원시적 형으로 초기화된다고?

Int, Double 등은 클래스이며 이 클래스로 타입을 명시하여 선언한 변수는 그 자체로 객체다. 
val intData: Int = 10
val result = intData.minus(5)
코틀린의 숫자 타입의 클래스들은 모두 Number타입의 서브 클래스문자는 NumberType이 아니다. 
NumberType에 대한 자동 형 변형을 제공하지 않는다.
암시적 형변환을 제공하지 않는다.

var mInt = 0
var mLong = 0L

mLong = mInt (불가능)
mLong = mInt.toLong() (가능)

자료형: 비트 사이즈
코틀린에서 문자는 숫자가 아니다. 

가독성을 증가시키기 위해 밑줄을 사용할 수 있다. 
표현
자바에서 숫자는 물리적으로 JVM 원시자료형에 저장된다.
우리가 nullable한 숫자 참조를 필요로 한다거나 제너릭이 포함된 숫자를 필요로 하지 않는 이상, 후자의 경우 숫자는 박싱된다. 

박싱 값 형식 -> 참조형식 = 박싱 스택에서 힙으로 데이터가 복사 -> 암시적으로 변환 가능
언박싱 참조 형식 -> 값 형식 = 언박싱 힙에서 스택으로 데이터가 복사 -> 명시적으로 변환 가능

박싱된 숫자는 identity 보존을 하지 않는다. 
객체가 다르다.

val a: Int = 1000
print(a === a) // Prints 'true'
val boxedA: Int? = a
val anotherBoxedA: Int? = a

print(boxedA === anotherBoxedA) // Prints 'false' <= 박싱된 숫자는 identity 보존을 하지 않는다.

값은 동일함
val a : Int = 1000
print(a == a)
val boxedA: Int? = a
val anotherBoxedA: Int? = a
print(boxedA == anotherBoxedA) // Prints 'true'

명시적 형변환
코틀린에서는 작은 자료형이 큰 자로형으로 속할 수 없다.

val a: Int? = 1
val b: Long? = a
print(a == b)

val b: Byte = 1
val i: Int = b


array -> get, set, size 메소드를 가지고 있고, []를 통해 아이템에 접근할 수 있다. 
class Array<T> private constructor(){
    val size: Int
    operator fun get(index: Int): T
    operator fun set(index: Int, value: T): Unit
    operator fun iterator(): Iterator<T>
}

배열을 만들기 위해서는 arrayOf()함수를 사용할 수 있다. 따라서 arrayOf(1,2,3)은 배열[1,2,3]을 만든다. arrayOfNulls()를 이용하여 null로 채워진 배열을 생성할 수도 있다. 
또 다른 방법으로는 배열의 크기와 초기값을 리턴하는 함수를 인자로 받는 Factory함수를 이용하는 것이다. 

val asc = Arrays(5, { i -> (i*i).toString()})
자바와 달리 코틀린에서 배열은 불변이다. 이것은 런타임에서 발생할 수 있는 오류를 방지하기 위해서 Array<Any>에 Array<String>을 할당할 수 없다는 것을 의미한다. 하지만 Array<out Any>는 가능하다. 

val x: IntArray = intArrayOf(1,2,3)
x[0] = x[1] + x[2]

코틀린은 배열에 특화된 원시타입의 배열 클래스도 박싱 오버헤드 없이 제공한다. 
이런 클래스들은 Array와 상속 관계가 없지만 메소드나 프로퍼티는 같다. 이들 각각에 상응하는 내장 함수 또한 가지고 있다. 

코틀린에는 String Literal의 두 가지 타입이 있다.
* escaped-string: escaped 문자를 갖는 문자열
* raw-string: 뉴라인을 포함할 수 있는 임의 텍스트(두 줄 이상 되나봄)
val text= """
    for(c in "foo")
    print(c)
"""

문자열은 템플릿 표현을 포함한다. 템플릿 표현은 달러 표시와 함께 시작된다. 
val i = 10
val s = "i = $i" // evaluates to "i = 10"

또는 중괄호 안에서 임의적인 표현이 가능하다. 
val s = "abc"
val str = "$s.length is ${s.length}"

raw-string에서 표현하고 싶다면
val price = """
${'$'}9.9
"""
템플릿은 두 가지 타입의 문자열에서 모두 지원하며 만약 달러 표시를 리터럴하게 raw-string에서 표현하고 싶다면 이렇게 쓰면 된다.

Any타입
코틀린 클래스의 최상위 클래스가 Any
fun getLength(obj: Any) : Int {
    if(obj is String) {
        return obj.length
    }
    return 0
}

fun main(args: Array<String>){
    println(getLength("Hello"))
    println(getLength(10))
}

fun cases(obj: Any): String {
    when(obj){
        1 -> return "One"
        "Hello" -> return "Greeting"
        is Long -> return "Long"
        !is String -> return "Not a string"
        else -> return "unknown"
     }
}

val a: Int = null
val a: Int? = null

fun parseInt(str: String): Int?{
    return str.toIntOrNull()
}

val myVal1: Any = 10
val myVal2: Any? = myVal1

val myVal3: Any? = 10
val myVal4: Any = myVal3 // error
val myVal5: Any = myVal3 as Any

val myInt1: Int = 10
val myInt2: Int? = myInt1

val myInt3: Int? = 10
val myInt4: Int = myInt3 // error
val myInt5: Int = myInt3 as Int

fun myFun1(){}
fun myFun2(): Unit{}

fun myFun(arg: Nothing?): Nothing{
    throw Exception()
}

* Array 타입
* 컬렉션 타입
Collection 타입의 클래스들은 mutable클래스와 immutable클래스로 구분된다.
kotlin.collection.List 인터페이스로 표현되는 객체는 immutable이며 size(), get()함수만 제공된다. 
kotlin.collection.MutableList 인터페이스로 표현되는 객체는 mutable이며 size(), get(), add(), set()함수만 제공된다. 

Iterable
Collection 
List, Set, Map -> Collection 타입의 클래스들은 mutable 클래스와 immutable 클래스로 구분된다. 

stack에 쌓인다.
주 생성자
- 클래스 선언부분에 작성
- 하나의 클래스에 하나의 주 생성자만 정의 가능

class User1 constructor(name:String, age:Int){}
class User2(name: String, age: Int){}
val user2 = User1("kkang", 33)
val user3 = User2("kim", 28)


class User3(name:String, age:Int=0){}
val user4 = User3("kkang", 33)
val user5 = User3("kkang")

생성자 
- 주생성자
- 매개변수를 가지는 주생성자
- 생성자 매개변수 기본값 명시
- 생성자 초기화 블록
- 생성자 매개변수 값 이용
    - 초기화 블록에서는 접근이 되는데 클래스에서 정의된 함수에서는 접근 불가능
    - 그래서 생성자 내에서 val, var을 이용하여 매개변수를 선언한다.

class User6(val name: String, val age: Int){
    val myName = name
    init {
        println("i am init... constructor argument: $name .. ${age}")
    }
    
    fun sayHello(){
        println("hello $name")
    }
}

주 생성자와 부 생성자
자바에서와 마찬가지로, 코틀린 역시 여러 개의 생성자를 정의할 수 있지만 그 방법이 조금 다르다. 코틀린에서 생성자는 '주 생성자'와 '부 생성자'로 구분된다. 
> 주 생성자
이 전 포스팅에서 예제로 들었던 Button 클래스의 정의를 다시 한번 살펴보자.
class Button {
    var id: Int = 0
}
생성자가 없는 것처럼 보이는데 주생성자가 생략되어 있는 상태. 자바와 마찬가지로 매개변수가 없는 생성자만 존재할 경우 생성자는 생략될 수 있다. 생략되기 전에는 아래와 같다. 

class Button(){
    var id: Int = 0
}

코틀린에서 주 생성자는 클래스 명 뒤에 괄호로 정의하며 생성자 파라미터에 의해 프로퍼티(멤버 변수 개념)를 초기화하기 위한 목적으로 사용된다. Button클래스는 매개변수가 없는 주 생성자를 사용하므로 빈 괄호를 쓸 수 있고, 주 생성자 외에 다른 생성자가 없으므로 주 생성자를 생략할 수 있다. 그런데 Button클래스에는 id라는 프로퍼티가 있고, 이 프로퍼티는 널타입이 아니기 때문에 반드시 초기화 되어야 한다. 주 생성자는 이런 프로퍼티들을 초기화하기 위한 목적으로 사용되므로, id 값을 매개 변수로 받는 주 생성자를 만들어 보자.

class Button(_id: Int){
    var id: Int = _id
}

코틀린에 조금씩 익숙해져 간다면 뭔가 하나 생략될 수 있는 부분이 하나 보일 건데
class Button(_id: Int){
    var id = _id // 타입 추론에 의해 생략 가능
}

주 생성자의 매개 변수는 타입을 추론할 수 없으므로 생략할 수 없다는 점은 유의할 것
위 예제만 봐도 코틀린 생성자 정의가 간단하다는 것을 알 수 있으나
주 생성자 정의와 프로퍼티 정의를 한꺼번에 할 수 있는 문법도 제공한다.

class Button(`var` id: Int){
}

주 생성자 정의와 프로퍼티 정의가 단 한줄로 끝난다. 여기에서 만일 클래스 내부에 더이상 프로퍼티나 멤버 메서드가 존재하지 않는다면 대괄호 역시 생략 가능
또 함수와 마찬가지로 매개 변수에 디폴트 값을 설정할 수 있음. 매개 변수가 두 개 이상일 경우 디폴트 값은 `뒤에서부터` 순서대로 설정해야 한다. "button.id"의 경우 코틀린 내부에서 프로퍼티 게터 함수를 호출하는 함수식으로 변환되므로 대괄호로 묶어줘야 한다.

> 부 생성자
코틀린에서는 주 생성자의 매개 변수에 디폴트 값을 설정할 수 있기 때문에 자바에 비해 여러 개의 생성자를 생성해야 할 필요성이 적다. 하지만 매개 변수의 타입이 다른 경우 필요한 경우 분명히 있기 때문에 부 생성자를 정의할 수 있도록 되어 있음. 

부 생성자는 클래스 명 대신 `constructor`라는 키워드를 사용하여 정의한다.

```Kotlin
class Button {
    var id: Int = 0
    var text: String = ""
    
    constructor(id: Int) {
        this.id = id
    }
    
    consturctor(id: Int, text: String){
        this.id = id
        this.text = text
    }
}
```

Int형 매개 변수 하나를 받는 부 생성자와 Int형과 String형 매개 변수를 받는 부 생성자를 정의했다. 이 경우 주생성자에는 아무것도 정의되어 있지 않은데, 매개 변수가 없는 생성자가 없다는 것을 의미한다. 만일 부 생성자를 정의했을 때 매개변수가 없는 생성자도 사용하고 싶다면 반드시 주 생성자 또는 부 생성자에 매개변수가 없는 생성자를 정의해줘야 한다. 

매개 변수가 없는 생성자를 사용하지 않는 경우를 가정하고 Int형 매개 변수 하나를 받는 생성자를 주 생성자로 만들어보자.

```Kotlin
class Button(var id: Int){
    var text: String = ""
    
    constructor(id: Int, text: String){
        this.id = id
        this.text = text
    }
}
```

근데 에러가 난다?
주 생성자를 호출하라는 에러가 난다. 
코틀린에서는 주 생성자가 정의된 경우, 부 생성자에서는 반드시 주 생성자를 재호출해야 한다. 필수로 초기화되는 프로퍼티들을 놓치지 않기 위해서이다.

부 생성자에서 주 생성자를 재호출하는 방법은 부 생성자 선언부 옆에 `:this`를 붙이는 것
```Kotlin
class Button(var id: Int){
    var text: String = ""
    
    constructor(id: Int, text: String)`: this`(id){
        this.text = text
    }
}
```

> 인자에 대한 디폴트 값을 제공하기 위해 부 생성자를 여러 개 만들지 말라. 대신 파라미터의 디폴트 값을 주 생성자 시그니처에 직접 명시하라. 

```Kotlin
class Button(var id: Int, var text: String = "", var isCheckbox: Booean =false)
```

```Kotlin
open class Shape{
    var x: Int = 0
        set(value){
            if(value < 0) field = 0
            else field = value
        }
        
    var y: Int = 0
        set(value){
            if(value < 0) field = 0
            else field = value
        }
        
    lateinit var name: String
    
    fun print(){
        println("$name : location : $x, $y")
    }
}


class Rect: Shape(){
    var width: Int = 0
        set(value){
            if(value < 0) field = 0
            else field = value
        }
    var height: Int = 0
        set(value){
            if(value < 0) field = 0
            else field = value
        }
}
```

* 함수를 선언하면 기본으로는 final
* final 클래스: 이 클래스를 상속받아 하위 클래스 작성 금지
* final 함수: 이 함수를 하위 클래스에서 오버라이드 금지
* final 프로퍼티: 프로퍼티 오버라이드 금지

* 함수의 오버라이드를 허용하려면 `open` 예약어로 명시해야 한다.
* override 예약어를 이용하여 이 함수는 상위 함수를 재정의한 것임을 명시적으로 선언

#### 프로퍼티 오버라이드

```Kotlin
open class Super {
    open val name: String = "kkang"
}

open class Sub: Super(){
    final override var name: String = "kim"
}
```

* 상위 클래스의 프로퍼티와 이름 및 타입이 동일해야 한다.
* 상위에 val로 선언된 프로퍼티는 하위에서 val, var로 재정의가 "가능" <- 제일 헷갈림
* 상위에서 var로 선언된 프로퍼티는 하위에서 var로 재정의 가능하다. 단 val은 불가능하다.
* 상위에서 Nullable로 선언된 경우 하위에서는 Non-Null로 선언 가능하다.
* 상위에서 Non-Null로 선언된 경우 하위에서는 Nullable로 재정의 불가능하다.
















































































    



















