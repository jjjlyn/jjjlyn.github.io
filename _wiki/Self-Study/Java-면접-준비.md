자바 메모리 구조는 메소드/ 힙/ 스택 영역으로 나뉜다. 
스택 영역에는 지역변수와 매개 변수가 저장된다. 
로컬변수는 메소드 내에서 선언된 변수들, 매개변수는 메소드에 아규먼트로 넘겨주는 값들로 이해하자.

로컬변수와 매개변수의 특징은 선언된 블록 안에서만 유효한 변수여서 스택 영역에 저장된다. 쉽게 말해 스택 영역에는 프로그램의 실행 과정에서 임시로 할당되고 그게 끝나면 소멸되는 것들이 저장된다. 즉 메소드가 호출될 때마다 그 메소드의 로컬 변수를 준비하고 메소드 호출이 끝나면 그 메소드를 위해 준비했던 모든 변수가 스택에서 제거된다. 

참조변수에 저장되는 메모리주소는 스택 영역에 저장되지만, 그 주소가 가리키는 메모리는 모두 힙 영역에 저장된다. 

public class StackMemoryTest{

코틀린은 자바에 뿌리를 두고 있기 때문에 자바와 유사한 점이 매우 많다. 따라서 자바에 대한 지식이 있다면 자바와 비교해 가며 공부하는 것이 코틀린을 배우는데 있어 가장 빠른 지름길이라고 생각한다. 
객체 -> 클래스라는 데이터 타입으로 선언된 메모리 or 변수
변수란 -> 메모리의 특정한 공간
- 선언 위치에 따라 크게 2가지로 나뉜다: 멤버변수(전역변수)/지역변수
- 멤버변수 선언 위치: 클래스 영역
- 지역변수 선언 위치: 메소드나 생성자 내부
- 멤버변수(전역변수)는 같은 클래스 내, 혹은 다른 클래스에서도 .을 찍어 호출이 가능하며 기능이 끝난 후에도 메모리 상에 지속적으로 남아있다. 지역변수는 {} 안에서만 사용가능하며, 괄호를 벗어나면 사용할 수 없다. (자동으로 삭제되어 호출 자체가 불가능, 따라서 다른 클래스에서도 호출 불가능하다.)

변수란 메모리의 특정 공간이다. 
스택에는 참조변수에 저장되는 메모리주소 예를 들어 MyCar genesis = MyCar()에서 genesis는 참조 변수로 객체의 메모리 주소가 저장된다(스택에 저장된다). 그리고 이 주소가 가리키는 메모리는 '힙'에 저장된다. 

멤버변수는 또 다시 2개로 나뉘는데 클래스 변수와 인스턴스 변수(= 객체 변수)
각각 객체(=인스턴스)마다 개별적인 속성값을 가져야 할 때 인스턴스 변수를 사용한다. (매번 인스턴스화를 해주어야 하는 객체 변수는 인스턴스화 될 때마다 서로 다른 저장공간을 가진다.)
a) String a= new String("a");
b) String b = new String("a");
둘은 힙 공간에 서로 다른 메모리로 할당된다.
반대로 클래스 변수는 모든 객체가 공통적으로 똑같은 속성을 가질 때 사용한다.
다시 말해 static으로 선언되는 것을 의미한다. static으로 선언된 것은, 클래스가 인스턴스화되지 않아도 독립적으로 메모리 할당을 받는다. (인스턴스화 해줄 필요가 없다) static으로 선언된다는 것은, 하나의 저장공간을 활용한다는 뜻이다. 따라서 공통적인 속성 유지시에 사용한다. 

Java Data Type
자바의 데이터 타입을 한번쯤 정리하여, 머릿속에 확실히 이미지화를 시키는 것은 꽤 중요한 작업이다. 우선 자바의 데이터 타입은 2가지로 나뉜다. 기본형과 레퍼런스 타입을 말한다. 기본형 데이터 타입은 다시 크게 숫자, 문자, 논리 3가지로 나뉘고, 레퍼런스 타입은 class, interface, Array, Enum으로 나뉜다. 

기본형 데이터 타입: 숫자, 문자, 논리
레퍼런스 타입: class, interface, array, enum
기본형과 레퍼런스 타입의 가장 큰 차이는, 
기본형은 메모리에 값이 들어가 정적할당을 받는 것이고
레퍼런스 타입은 메모리에 주소값이 올라가서 동적할당을 받는 것이다(실행 중 데이터 할당)

상수
변수에 이어 상수는 무엇인가?
상수를 변수의 반대인 '변하지 않는 수'라고 대답하면 안된다.
상수는 '메모리의 값'이란 표현이 가장 적당하다. 상수는 final을 이용하여 선언하는데, 이 final이라는 것은 쓰이는 순간 크게 3가지를 금지한다. 클래스 차원에서는 상속 금지, 메소드 차원에서는 오버라이딩을 금지, 필드 차원에서는 값 변경을 금지시킨다. 왜 이 3가지가 금지될까라는 것이 이해가 안된다면, 다시 한번 '상수는 메모리의 값'이라는 표현을 잘 생각해 보면 된다.

Ram(memory)
객체의 개념을 정확하게 이해하기 위해서는 Ram에 대해 알아둘 필요성이 있다. 프로그램이 실행 중, 수시로 메모리 할당과 반환이 이루어지는 것을 동적이라고 하며, 프로그램이 끝날 때까지 변하지 않고 계속해서 살아있는 것을 정적인 영역이라고 한다. 
ram은 크게 4가지 영역으로 나뉜다.
- data 영역: (정적) 전역, 정적(static) 변수가 저장되는 공간이며, 실행부터 끝까지 지속적으로 쓰이는 변수들이기에 마지막까지 메모리에서 살아남는다.  
- heap 영역: 개발자가 직접 동적으로 할당을 건드리는 영역. 힙 영역은 메모리 주소 값에 의해서만 참조되고 사용되는 영역. (래퍼런스 타입의 저장소) - 필드나 메소드 등을 포함, 인스턴스화가 된 객체 변수의 메모리 값을 할당해주는 역할
사실 Stack의 바닥에는 객체 변수가 주소값만 가진 상태로 머물고 있다. 이 상태에서, 힙 영역을 할당받아 힙의 객체 메모리를 할당받는 과정을 '인스턴스 화'라고 하고, 완료된 것을 인스턴스라고 한다. 
- stack 영역: 지역, 파라미터 변수가 저장된다. 호출 순서에 따라 차례차례 메모리에 쌓이고 나가는 구조다. 함수의 파라미터나 함수 안에서 선언된 변수들 및 리턴값들이 저장된다. 함수가 실행될 때 메모리에 생성, 완료되면 다시 반환하는 동적인 구조다.  
- code 영역: 함수와 상수가 저장되는 공간. 정적 공간
인스턴스를 정의하는 가장 큰 이유는 인스턴스의 메소드와 변수를 사용하기 위해서이다. 즉 인스턴스를 생성하지 않고는 해당 필드 및 메소드를 사용할 수 없다는 뜻이기도 하며 생성자는 인스턴스가 생성될 때 호출되는 인스턴스 초기화 메서드다.

가비지 컬렉션 과정 - Generational Garbage Collection
GC에 대해 알아보기 전에 알아야 할 용어가 있다. stop-the-world란 GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것이다. stop-the-world가 발생하면 GC를 실행하는 쓰레드를 제외한 나머지 쓰레드는 모두 작업을 멈춘다. GC 작업을 완료한 이후에야 중단했던 작업을 다시 시작한다. 어떤 GC알고리즘을 사용하더라도 stop-the-world는 발생한다. 대개의 경우 GC튜닝이란 이 stop-the-world 시간을 줄이는 것이다. Java 프로그램 코드에서 메모리를 명시적으로 지정하여 해제하지 않는다. 가끔 명시적으로 해제하려고 해당 객체를 null로 지정하거나 System.gc() 메서드를 호출하는 개발자가 있다. null로 지정하는 것은 큰 문제가 안 되지만, System.gc() 메서드를 호출하는 것은 시스템 성능에 매우 큰 영향을 끼치므로 System.gc() 메서드는 절대로 사용하면 안 된다.
Java에서는 개발자가 프로그램 코드로 메모리를 명시적으로 해제하지 않기 때문에 가비지 컬렉터가 더 이상 필요없는 객체를 찾아 지우는 작업을 한다. 이 가비지 컬렉터는 두 가지 가설 하에 만들어졌다(사실 가설이라기보다는 가정 또는 전제 조건이라고 표현하는 것이 맞다).
Java에서는 개발자가 프로그램 코드로 메모리를 명시적으로 해제하지 않기 때문에 가비지 컬렉터가 더 이상 필요없는 객체를 찾아 지우는 작업을 한다. 이 가비지 컬렉터는 두 가지 가설 하에 만들어졌다. 
- 대부분의 객체는 금방 접근 불가능한 상태가 된다.
- 오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다. 
  이러한 가설을 'weak generational hypothesis'라고 한다. 이 가설의 장점을 최대한 살리기 위해서 HotSpot VM에서는 크게 2개의 물리적 공간으로 나누었다. 둘로 나눈 공간이 Young 영역과 Old 영역이다. 
- Young 영역: 새롭게 생성한 객체의 대부분이 여기에 위치한다. 대부분의 객체가 금방 접근 불가능한 상태가 되기 때문에 매우 많은 객체가 Young 영역에 생성되었다가 사라진다. 이 영역에서 객체가 사라질 때 Minor GC가 발생한다고 말한다.
- Old 영역: 접근 불가능 상태로 되지 않아 Young 영역에서 살아남은 객체가 여기로 복사된다. 대부분 Young 영역보다 크게 할당하며, 크기가 큰 만큼 Young 영역보다 GC가 적게 발생한다. 이 영역에서 객체가 사라질 때 Major GC(혹은 Full GC)가 발생한다고 말한다. 영역별 데이터 흐름을 그림으로 살펴보면 다음과 같다. 
위 그림의 Permanent Generation 영역(이하 Perm 영역)은 Method Area라고 한다. 객체나 억류된 문자열 정보(intern)를 저장하는 곳이며, Old영역에서 살아남은 객체가 영원히 남아있는 곳은 절대 아니다. 이 영역에서 GC가 발생할 수도 있는데, 여기서 GC가 발생해도 Major GC의 횟수에 포함된다. 
그렇다면 "Old 영역에 있는 객체가 Young 영역의 객체를 참조하는 경우가 있을 때에는 어떻게 처리될까?" 이러한 경우를 처리하기 위해서 Old 영역에는 512바이트의 덩어리(chunk)로 되어있는 카드 테이블이 존재한다. 카드 테이블에는 Old 영역에 있는 객체가 Young 영역의 객체를 참조할 때마다 정보가 표시된다. Young 영역의 GC를 실행할 때에는 Old 영역에 있는 모든 객체의 참조를 확인하지 않고, 이 카드 테이블만 뒤져서 GC 대상인지 식별한다. 카드 테이블에는 Old 영역에 있는 객체가 Young 영역의 객체를 참조할 때마다 정보가 표시된다. Young 영역의 GC를 실행할 때에는 Old 영역에 있는 모든 객체의 참조를 확인하지 않고 이 
